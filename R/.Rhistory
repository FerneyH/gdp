setwd()
getwd()
devtools::document("C:/Users/fhenaoceballos/Documents/R/gdp")
devtools::check("C:/Users/fhenaoceballos/Documents/R/gdp")
devtools::document("C:/Users/fhenaoceballos/Documents/R/gdp")
devtools::check("C:/Users/fhenaoceballos/Documents/R/gdp")
generate_event_locations <- function(geography=c("state", "county", "zcta", "cbsa","combined statistical area"),
rate,
population,
family = c("poisson", "negative_binomial"),
control = list(),
rate_per= 1000,
state = NULL,
county = NULL,
labels = NULL,
probs = NULL,
time = 1,
warn = TRUE,
...) {
geography <- match.arg(geography)
# Sanity checks
if (is.null(labels) && is.null(probs)) {
labels <- "event"
probs  <- 1
} else if (!is.null(labels) && is.null(probs)) {
probs <- rep(1 / length(labels), length(labels))
} else if (is.null(labels) && !is.null(probs)) {
stop("If 'probs' is provided, 'labels' must also be provided.")
} else {
if (length(labels) != length(probs)) {
stop("'labels' and 'probs' must have the same length")
}
if (abs(sum(probs) - 1) > 1e-6) {
stop("Probabilities do not sum to 1.")
}
}
if(!is.logical(warn) || length(warn) != 1) stop("warn must be TRUE or FALSE")
datatemp<-get_rates(rate = rate,population=population, rate_per=rate_per,state = state,county = county)
# Family distribution
family <- match.arg(family)
# Generate counts based on distribution family
datatemp$mu <- switch(family,
poisson = rpois(n = rep(1,nrow(datatemp)), lambda = datatemp$estimated),
negative_binomial = rnbinom(n = rep(1,nrow(datatemp)), mu = datatemp$estimated, size = control$size))
USA_pop_density<-get_density(geography=geography,state = state, county = county)
# Pixel resolution
res=unique(USA_pop_density[[1]]$res_pixel)
# The coverage area is square meters, we need square kilometers
USA_pop_density_counties<-USA_pop_density%>%dplyr::bind_rows(.id="geoid")%>%dplyr::mutate(coverage_area=coverage_area/1e6)
# weights for population density
USA_pop_density_counties_weights<-USA_pop_density_counties%>%dplyr::group_by(geoid)%>%
dplyr::mutate(weight=(value*coverage_area)/sum(value*coverage_area,na.rm = TRUE))%>%
dplyr::mutate(weight=ifelse(is.na(weight),0,weight))
# Combining density population and datatemp
USA_pop_density_counties_weights_mu<-USA_pop_density_counties_weights%>%dplyr::full_join(datatemp,by="geoid")
# Random events, generating labels
random_events_per_cell<-USA_pop_density_counties_weights_mu%>%dplyr::ungroup()%>%
dplyr::group_split(geoid)%>%
purrr::map_dfr(., ~ slice_sample(.x,n=unique(.x$mu), weight_by =.x$weight,replace = TRUE))%>%
dplyr::mutate(labels=sample(labels,length(.$geoid),replace = TRUE,prob = probs))%>%
dplyr::select(c("x", "y", "labels", "geoid", "display_name"))
## Accept-reject sampling
# Creating the boundary for intersections, it only checks specific county or state
boundary <- get_boundary(geography =geography, state =state, county = county)
boundary <- boundary%>%dplyr::select(GEOID,geometry)%>%st_transform("EPSG:4326")
names(boundary) <- tolower(names(boundary))
sampled_points<-accept_reject_sampling(random_events_per_cell,boundary,res)
sampled_points<-left_join(sampled_points,boundary,by=geoid)
return(sampled_points)
}
library(gdp)
data(Stroke_Rate)
population<-get_census_population(geography="county")
strokes<-generate_event_locations(geography="county",
rate=Stroke_Rate,
population = population,
family = "negative_binomial",
control = list(size=10),
state = "19")
generate_event_locations <- function(geography=c("state", "county", "zcta", "cbsa","combined statistical area"),
rate,
population,
family = c("poisson", "negative_binomial"),
control = list(),
rate_per= 1000,
state = NULL,
county = NULL,
labels = NULL,
probs = NULL,
time = 1,
warn = TRUE,
...) {
geography <- match.arg(geography)
# Sanity checks
if (is.null(labels) && is.null(probs)) {
labels <- "event"
probs  <- 1
} else if (!is.null(labels) && is.null(probs)) {
probs <- rep(1 / length(labels), length(labels))
} else if (is.null(labels) && !is.null(probs)) {
stop("If 'probs' is provided, 'labels' must also be provided.")
} else {
if (length(labels) != length(probs)) {
stop("'labels' and 'probs' must have the same length")
}
if (abs(sum(probs) - 1) > 1e-6) {
stop("Probabilities do not sum to 1.")
}
}
if(!is.logical(warn) || length(warn) != 1) stop("warn must be TRUE or FALSE")
datatemp<-get_rates(rate = rate,population=population, rate_per=rate_per,state = state,county = county)
# Family distribution
family <- match.arg(family)
# Generate counts based on distribution family
datatemp$mu <- switch(family,
poisson = rpois(n = rep(1,nrow(datatemp)), lambda = datatemp$estimated),
negative_binomial = rnbinom(n = rep(1,nrow(datatemp)), mu = datatemp$estimated, size = control$size))
USA_pop_density<-get_density(geography=geography,state = state, county = county)
# Pixel resolution
res=unique(USA_pop_density[[1]]$res_pixel)
# The coverage area is square meters, we need square kilometers
USA_pop_density_counties<-USA_pop_density%>%dplyr::bind_rows(.id="geoid")%>%dplyr::mutate(coverage_area=coverage_area/1e6)
# weights for population density
USA_pop_density_counties_weights<-USA_pop_density_counties%>%dplyr::group_by(geoid)%>%
dplyr::mutate(weight=(value*coverage_area)/sum(value*coverage_area,na.rm = TRUE))%>%
dplyr::mutate(weight=ifelse(is.na(weight),0,weight))
# Combining density population and datatemp
USA_pop_density_counties_weights_mu<-USA_pop_density_counties_weights%>%dplyr::full_join(datatemp,by="geoid")
# Random events, generating labels
random_events_per_cell<-USA_pop_density_counties_weights_mu%>%dplyr::ungroup()%>%
dplyr::group_split(geoid)%>%
purrr::map_dfr(., ~ slice_sample(.x,n=unique(.x$mu), weight_by =.x$weight,replace = TRUE))%>%
dplyr::mutate(labels=sample(labels,length(.$geoid),replace = TRUE,prob = probs))%>%
dplyr::select(c("x", "y", "labels", "geoid", "display_name"))
## Accept-reject sampling
# Creating the boundary for intersections, it only checks specific county or state
boundary <- get_boundary(geography =geography, state =state, county = county)
boundary <- boundary%>%dplyr::select(GEOID,geometry)%>%st_transform("EPSG:4326")
names(boundary) <- tolower(names(boundary))
sampled_points<-accept_reject_sampling(random_events_per_cell,boundary,res)
sampled_points<-left_join(sampled_points,boundary,by="geoid")
return(sampled_points)
}
strokes<-generate_event_locations(geography="county",
rate=Stroke_Rate,
population = population,
family = "negative_binomial",
control = list(size=10),
state = "19")
strokes<-generate_event_locations(geography="county",
rate=Stroke_Rate,
population = population,
family = "negative_binomial",
control = list(size=10),
state = "19")
strokes
